---
sticky: true
date: 2022-08-02
category:
- 设计模式
tag:
- 知识点

---
将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构
<!-- more -->

# 结构型模式



## 1.适配器模式

### 1.介绍

> 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本.
> 因接口不匹配不能- -起工作的两个类可以协同工作。其别名为包装器(Wrapper)
> 适配器模式属于结构型模式主要分为三类:类适配器模式、对象适配器模式、接口适配器模式



适配器模式:将一个类的接口转换成另-种接口.让原本接口不兼容的类可以兼容
从用户的角度看不到被适配者，是解耦的用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法用户收到反馈结果，感觉只是和目标接口交互

### 2.类适配器模式

>  基本介绍: Adapter类，通过继承src类，实现dst 类接口，完成src->dst的适配。

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter,220V交流电相当于sre(即被适配者)，我们
的目dst(即目标)是5V直流电

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012219231.png" alt="image-20220801221850616" style="zoom: 33%;" />

这里classadpter继承Voltage220V并实现IVoltage5V接口

client直接调用phone 和classadpter，然后classadpter在实现IVoltage5V接口的时候会调用Voltage220V方法的同时进行转换，最后输出合适的电压

```
//适配器接口
public interface IVoltage5V {
    public int output5V();

}
//被适配的类
public class Voltage220V {
    //输出220V的电压
    public int output220V() {
        int src = 220;
        System.out.println("电压=" + src + "伏");
        return src;
    }
}
//适配器类
public class ClassAdapter extends Voltage220V implements IVoltage5V {

    public int output5V() {
        //获取到220V电压
        int srcV = output220V();
        int dstV = srcV / 44 ; //转成 5v
        return dstV;
    }

}
//对象适配器
public class ObjectAdapter implements IVoltage5V{

    public Voltage220V voltage220V;

    public ObjectAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    public int output5V() {
        int dst = 0;
        if(null != voltage220V) {
            int src = voltage220V.output220V();//获取220V 电压
            System.out.println("使用对象适配器，进行适配~~");
            dst = src / 44;
            System.out.println("适配完成，输出的电压为=" + dst);
        }

        return dst;
    }
}
//操作类适配器和对象适配器
public class Client{
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new ClassAdapter());
        System.out.println("------------");
        phone.charging(new ObjectAdapter(new Voltage220V()));
    }
}
```

```
public interface interfaceDemo {
    public void fun1();
    public void fun2();
    public void fun3();
    public void fun4();
}
//InterfaceAdapter 我们将 interfaceDemo 的方法进行默认实现
public abstract class InterfaceAdapter implements interfaceDemo{
    //默认实现
    public void fun1() {

    }

    public void fun2() {

    }

    public void fun3() {

    }

    public void fun4() {

    }
}

public class Client {
    public static void main(String[] args) {
        InterfaceAdapter interfaceAdapter=new InterfaceAdapter(){
            @Override
            public void fun1() {
                System.out.println("实现fun1方法");
            }
        };
        interfaceAdapter.fun1();
    }
}
```



>  注意事项：

Java是单继承机制，所以类适配器需要继承sre类这一点算是一 -个缺点，因为这要求dst必须是接口，有一定局限性;
sre类的方法在Adapter中都会暴露出来，也增加了使用的成本。
由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

### 3.对象适配器模式

> 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承sre类，而是持有src类的实例，以解决
> 兼容性的问题。即: 持有src类， 实现dst 类接口，完成src->dst的适配
> 根据“合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系。
> 对象适配器模式是适配器模式常用的一种

案例：

同样是之前的例子，这里用objectadapter对象适配器，其聚合了Voltage220，直接调用Voltage220的方法实现转换

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012229481.png" alt="image-20220801222912221" style="zoom:25%;" />

>  注意事项：

对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。
根据合成复用原则，使用组合替代继承，所以它 解决了类适配器必须继承src的局限性问题，也不再要求dst
必须是接口。
使用成本更低，更灵活。

### 4.接口适配器模式

> 核心思路:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
> 适用于一个接口不想使用其所有的方法的情况。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012233711.png" alt="image-20220801223306965" style="zoom:25%;" />

抽象类InterfaceAdapter实现interfaceDemo接口，实现其方法，但没有添加任何具体的实现细节代码

在client调用InterfaceAdapter时，可以按照需求实现某一个方法，而不用实现其他方法

### 5.适配器模式在SpringMVC框架应用的源码剖析

![image-20220801232437321](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012324554.png)

适配器模式的注意事项和细节
1)三种命名方式，是根据src是以怎样的形式给到Adapter (在Adapter里的形式)来
命名的。
2)类适配器:以类给到，在Adapter里，就是将src当做类，继承
对象适配器:以对象给到，在Adapter里， 将src作为 -一个对象，持有
接口适配器:以接口给到，在Adapter里，将src作为一- 个接口，实现

3)Adapter模式最 大的作用还是将原本不兼容的接口融合在一起工作。
4)实际开发中，实现起来不拘泥于我们讲解的三种经典形式



## 2.桥接模式

### 1.基本介绍

> 桥接模式(Bridge模式)是指:将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。是一种结构型设计模式
> Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要
> 特点是把抽象(Abstraction)与行为实现(Implementation)分离开来,从而可以保持各部分的独立性以及应对他们的功能扩展

### 2.案例：

现在对不同手机类型的不同品牌实现操作编程(比如:开机、关机、上网，打电话等

接口brand，其下的huawei和redmi是具体的实现类

抽象类phone聚合了brand了，并有具体的子类继承去实现不同的功能

然后clinet在调用的时候，直接new一个具体的Phone，然后内部给一个具体的品牌，实现桥接。

如果新增了品牌或者功能直接增加一个实现或继承对应的接口或类，不必更改代码

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208020926498.png" alt="image-20220802092628459" style="zoom:33%;" />

```
public interface Brand {
    void open();
    void close();
    void call();
}

public class Redmi implements Brand{
    public void open() {
        System.out.println(" 小米手机开机 ");

    }

    public void close() {
        System.out.println(" 小米手机关机 ");

    }

    public void call() {
        System.out.println(" 小米手机打电话 ");

    }
}
public class Huawei implements Brand{
    public void open() {
        System.out.println(" 华为手机开机 ");

    }

    public void close() {
        System.out.println(" 华为手机关机 ");

    }

    public void call() {
        System.out.println(" 华为手机打电话 ");

    }
}

public abstract class Phone {
    private Brand brand;

    public Phone(Brand brand) {
        super();
        this.brand = brand;
    }
    protected void open() {
        this.brand.open();
    }
    protected void close() {
        brand.close();
    }
    protected void call() {
        brand.call();
    }
}

public class CurvedPhone extends Phone{
    public CurvedPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println(" 曲面屏手机 ");
    }

    public void close() {
        super.close();
        System.out.println(" 曲面屏手机 ");
    }

    public void call() {
        super.call();
        System.out.println(" 曲面屏手机 ");
    }
}
public class OverPhone extends Phone{
    public OverPhone(Brand brand) {
        super(brand);
    }

    public void open() {
        super.open();
        System.out.println(" 全面屏手机 ");
    }

    public void close() {
        super.close();
        System.out.println(" 全面屏手机 ");
    }

    public void call() {
        super.call();
        System.out.println(" 全面屏手机 ");
    }
}

public class Client {
    public static void main(String[] args) {
        Phone curvedPhone = new CurvedPhone(new Huawei());
        curvedPhone.call();

        System.out.println("---------------");
        Phone overPhone = new OverPhone(new Redmi());
        overPhone.open();
    }
}
```



### 3.桥接模式在JDBC的源码剖析

>  Jdbc 的Driver接口，如果从桥接模式来看，Driver就是一一个接口，下面可以有MySQL的Driver， Oracle的Driver，这些就可以当做实现接口类

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208021054448.png" alt="image-20220802105447001" style="zoom:33%;" />

### 4.桥接模式的注意事项和细节
1)实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于
系统进行分层设计，从而产生更好的结构化系统。
2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。

4)桥接模式的引入增 加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5)桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。

 **常见的应用场景:**

1) JDBC驱动程序
2) 银行转账系统
  转账分类:网上转账，柜台转账，AMT 转账
  转账用户类型:普通用户，银卡用户，金卡用户..
3) 消息管理
  消息类型:即时消息，延时消息
  消息分类:手机短信，邮件消息，QQ消息..



## 3.装饰者模式

### 1.介绍

> 装饰者模式:动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)



### 2.案例：

咖啡种类/单品咖啡: Espresso( 意大利浓咖啡)、ShortBlack(单品咖啡)、 LongBlack(美式咖啡)、
调料: Milk、 Soy(豆浆)、 Chocolate
要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
使用00的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。



Drink类是一个抽象类 ，而ShortBlack就是单品咖啡是其一个继承子类
Decorator是一个装饰类，含有一个被装饰的对象(Drink obj)
Decorator的cost方法进行一个费用的叠加计算，递归的计算价格

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022107098.png" alt="image-20220802210742954" style="zoom:33%;" />

```
public abstract class Drink {
    public String desc;
    private float price =0.0f;

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }
    //计算费用的抽象方法
    public abstract float cost();

}
public class Coffee extends Drink{
    public float cost() {
        return super.getPrice();
    }
}
public class Espresso extends Coffee{
    public Espresso() {
        setDesc(" 意大利咖啡 ");
        setPrice(6.0f);
    }
}
public class ShortBlack extends Coffee{
    public ShortBlack() {
        setDesc(" shortblack ");
        setPrice(4.0f);
    }
}
    public LongBlack() {
        setDesc(" longblack ");
        setPrice(5.0f);
    }
}
public class Decorator extends Drink{
    private Drink obj;

    public Decorator(Drink obj) {
        this.obj = obj;
    }

    public float cost() {
        return super.getPrice() + obj.cost();
    }

    public String getDes() {
        // obj.getDes() 输出被装饰者的信息
        return desc + " " + getPrice() + " && " + obj.getDesc();
    }
}
public class Soy extends Decorator{
    public Soy(Drink obj) {
        super(obj);
        setDesc(" 豆浆  ");
        setPrice(1.5f);
    }
}
public class Milk extends Decorator{
    public Milk(Drink obj) {
        super(obj);
        setDesc(" 牛奶 ");
        setPrice(2.0f);
    }
}
public class Chocolate extends Decorator{
    public Chocolate(Drink obj) {
        super(obj);
        setDesc(" 巧克力 ");
        setPrice(3.0f); // 调味品 的价格
    }
}
```



### 3.装饰者模式在JDK应用的源码分析

![image-20220802211930062](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022119754.png)

1. InputStream是抽象类,类似我们前面讲的Drink
2. FileInputStream是InputStream 子类，类似我们前面的DeCaf, LongBlack
3. FilterInputStream是InputStream 子类:类似我们前面的Decorator 修饰者
4. DatalnputStream是FilterInputStream 子类，具体的修饰者，类似前面的Milk, Soy等.
5. FilterInputStream类有protected volatile InputStream in;即含被装饰者
6. 分析得出在jdk的io体系中，就是使用装饰者模式

## 4.组合模式

### 1. 基本介绍

> 组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示"整体-部分”的层次关系。
> 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式。
> 组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客户以一致的方式处理个别对象以及组合对象
>
> 组合模式解决这样的问题，当我们的要处理的对象可以生成-颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一-致的方式，而不用考虑它是节点还是叶子

**组合模式原理图**

![image-20220802224724142](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022257402.png)
对原理结构图的说明-即(组合模式的角色及职责)

1) Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理
Component子部件, Component可以是抽象类或者接口
2) Leaf: 在组合中表示叶子节点，叶子节点没有子节点
3) Composite :非叶子节点，用 于存储子部件，在Component接口中实现 子部件的相关操作，比如增加(add),
删除。

### 2. 案例

编写程序展示一个学校院系结构:需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。 

organizationComponent是所有类共有的接口，用于访问和管理所有的子部件

university，college是学校和院系是非叶子结点，而department是学院是叶子结点，

university通过organizationComponent聚合了college，而college通过organizationComponent聚合了department，然后对其进行一些相关操作，比如add和删除，如果还有其他类别，直接添加对应的类别即可





![image-20220802222338235](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022223082.png)

```
public abstract class OrganizationComponent {
    private String name; // 名字
    private String des; // 说明

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    protected  void add(OrganizationComponent organizationComponent) {
        //默认实现
        throw new UnsupportedOperationException();
    }

    protected  void remove(OrganizationComponent organizationComponent) {
        //默认实现
        throw new UnsupportedOperationException();
    }

    //方法print, 做成抽象的, 子类都需要实现
    protected abstract void print();
}

//University 就是 Composite , 可以管理College
public class University extends OrganizationComponent{
    //用于存College
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }


    public University(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println("*****" + getName());
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
public class College extends OrganizationComponent{
    //用于存Department
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    public College(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println("--------------" + getName() + "--------------");
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
public class Department extends OrganizationComponent{
    //没有集合

    public Department(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println(getName());

    }
}
public class Client {
    public static void main(String[] args) {
        //从大到小创建对象 学校
        OrganizationComponent university = new University("清华大学", " 中国顶级大学 ");

        //创建 学院
        OrganizationComponent computerCollege = new College("计算机学院", " 计算机学院 ");
        OrganizationComponent infoEngineercollege = new College("信息工程学院", " 信息工程学院 ");


        //创建各个学院下面的系(专业)
        computerCollege.add(new Department("软件工程", " 软件工程不错 "));
        computerCollege.add(new Department("网络工程", " 网络工程不错 "));
        computerCollege.add(new Department("计算机科学与技术", " 计算机科学与技术是老牌的专业 "));


        infoEngineercollege.add(new Department("通信工程", " 通信工程不好学 "));
        infoEngineercollege.add(new Department("信息工程", " 信息工程好学 "));

        //将学院加入到 学校
        university.add(computerCollege);
        university.add(infoEngineercollege);

        //university.print();
        infoEngineercollege.print();
    }
}
```



### 3.组合模式在JDK集合的源码分析

![image-20220802223322623](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022233036.png)

### 4.组合模式的注意事项和细节

1)简化客户端操作。客户端只需要面对--致的对象而不用考虑整体部分或者节点叶子的问题。
2)具有 较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4)需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式，
5)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式