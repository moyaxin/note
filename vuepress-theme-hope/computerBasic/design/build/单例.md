## 1.单例模式

### 1.饿汉式（静态常量）:star:

- 优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步的问题
- 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，则会造成内存浪费

**这种单例模式可用，但可能造成内存浪费**

### 2.饿汉式（静态代码块）

同上一个

### 3.懒汉式 线程不安全



- 起到了Lazy Loading的效果，但是只能在单线程下使用
- 多线程情况下，一个线程进入了if判断，还未往下执行，另一个线程也通过了if判断就会产生多个实例

**不要使用这种方式**

### 4.懒汉式 线程安全 同步代码块 双重检查:star:

![img](https://cdn.nlark.com/yuque/0/2022/png/26424970/1658842966061-2270e753-d76e-4ff4-a575-32b40d79d144.png)

- Double-Check概念是多线程开发中常使用到的，因为用了两次if判断检查，可以保证线程安全
- 此外，实例代码只执行一次，下次执行的时候，会因为外面的if判断而直接return实例化对象，避免反复进行方法同步

**线程安全、延迟加载、效率较高，推荐使用**



### 5.静态内部类 :star:

- 使用了类装载的机制来保证初始化实例时只有一个线程
- 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实力化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化
- 类的静态属性只会在第一次加载类的时候初始化，JVM帮助我保证了线程的安全性，在类进行初始化，别的线程是无法进入的

**避免了线程不安全，利用静态内部类特点实现延迟加载，效率高，推荐使用**



### 6.枚举  :star



借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象



### 7.单例模式的注意事项和细节说明



1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以保证系统性能
2. 当想要实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3. **使用场景：**需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象（如数据源、session工厂）

### 8.单例模式在JDK应用的源码分析

```
Runtime runtime=Runtime.getRuntime();
```

![image-20220731135307050](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050656.png)
