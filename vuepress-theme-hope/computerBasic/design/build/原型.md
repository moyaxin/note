## 3.原型模式

### 1.介绍

> 原型模式(Prototype模式) ，用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
> 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
> 工作原理是:通过将-一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()



案例：

现在有一只羊tom,姓名为:tom,年龄为: 1，颜色为:白色， 请编写程序创建和tom羊属性完全相同的10 .
只羊。

最容易想到的就是直接用构造方法，造十个

还有就是直接实现cloneable接口，用clone方法

```

public class CloneSheep {
    public static void main(String[] args) {
        //原始的拷贝
        Sheep sheep = new Sheep("duoli",13,"blue");
        Sheep sheep1 = new Sheep("duoli", 13, "blue");
        Sheep sheep2 = new Sheep("duoli", 13, "blue");
        Sheep sheep3 = new Sheep("duoli", 13, "blue");
        Sheep sheep4 = new Sheep("duoli", 13, "blue");
        //如果sheep发生了改变，比如多了一个属性，那么1234都要加个属性



        //使sheep实现cloneable接口，使用其默认的clone方法
        //可以解决sheep发生改变，而以下代码无需改变
        Sheep sheep_ = new Sheep("duoli",14,"blue");
        Sheep clone1 = sheep_.clone();
        Sheep clone2 = sheep_.clone();
        Sheep clone3 = sheep_.clone();
        Sheep clone4 = sheep_.clone();

    }
}
```



### 2.**浅拷贝的介绍**

> 1). 对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递，也就是将该属性值复制--份给新的对象。
> 2). 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值

前面我们克隆羊就是浅拷贝
浅拷贝是使用默认的clone()方法来实现

### 3.**深拷贝的介绍**

> 复制对象的所有基本数据类型的成员变量值
> 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象
> 可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
> 深拷贝实现方式1:重写clone方法来实现深拷贝
> 深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)

案例：上诉的sheep加一个引用类型：sheepType

然后两种深拷贝的实现方式如下：

```
//深拷贝 - 方式 1 使用clone 方法
	@Override
	protected Sheep clone()  {

		Sheep sheep = null;
		try {
			sheep = (Sheep)super.clone();
			//对引用属性单独处理
			sheep.sheepType=(SheepType)sheepType.clone();
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		}
		return sheep;
	}
	
	
	//深拷贝 - 方式2 通过对象的序列化实现 (推荐)
	public Sheep deepClone(){
		//创建流对象
		ByteArrayOutputStream bos=null;
		ObjectOutputStream oos=null;

		ByteArrayInputStream bis=null;
		ObjectInputStream ois=null;

		Sheep sheep =null;
		try{
			//先序列化
			bos=new ByteArrayOutputStream();
			oos=new ObjectOutputStream(bos);
			oos.writeObject(this); //当前这个对象以对象流的方式输出

			//再反序列化
			bis=new ByteArrayInputStream(bos.toByteArray());
			ois=new ObjectInputStream(bis);
			sheep=(Sheep) ois.readObject();
		}catch (Exception e){
			e.printStackTrace();
		}finally {
			//关闭流
			try {
				bos.close();
				oos.close();
				bis.close();
				ois.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
		}
		return sheep;
	}
```

### 4.原型模式在Spring框架中源码分析
![image-20220731155552062](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050709.png)
