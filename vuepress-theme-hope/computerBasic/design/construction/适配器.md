## 1.适配器模式

### 1.介绍

> 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本.
> 因接口不匹配不能- -起工作的两个类可以协同工作。其别名为包装器(Wrapper)
> 适配器模式属于结构型模式主要分为三类:类适配器模式、对象适配器模式、接口适配器模式



适配器模式:将一个类的接口转换成另-种接口.让原本接口不兼容的类可以兼容
从用户的角度看不到被适配者，是解耦的用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法用户收到反馈结果，感觉只是和目标接口交互

### 2.类适配器模式

>  基本介绍: Adapter类，通过继承src类，实现dst 类接口，完成src->dst的适配。

以生活中充电器的例子来讲解适配器，充电器本身相当于Adapter,220V交流电相当于sre(即被适配者)，我们
的目dst(即目标)是5V直流电

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012219231.png" alt="image-20220801221850616" style="zoom: 33%;" />

这里classadpter继承Voltage220V并实现IVoltage5V接口

client直接调用phone 和classadpter，然后classadpter在实现IVoltage5V接口的时候会调用Voltage220V方法的同时进行转换，最后输出合适的电压

```
//适配器接口
public interface IVoltage5V {
    public int output5V();

}
//被适配的类
public class Voltage220V {
    //输出220V的电压
    public int output220V() {
        int src = 220;
        System.out.println("电压=" + src + "伏");
        return src;
    }
}
//适配器类
public class ClassAdapter extends Voltage220V implements IVoltage5V {

    public int output5V() {
        //获取到220V电压
        int srcV = output220V();
        int dstV = srcV / 44 ; //转成 5v
        return dstV;
    }

}
//对象适配器
public class ObjectAdapter implements IVoltage5V{

    public Voltage220V voltage220V;

    public ObjectAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    public int output5V() {
        int dst = 0;
        if(null != voltage220V) {
            int src = voltage220V.output220V();//获取220V 电压
            System.out.println("使用对象适配器，进行适配~~");
            dst = src / 44;
            System.out.println("适配完成，输出的电压为=" + dst);
        }

        return dst;
    }
}
//操作类适配器和对象适配器
public class Client{
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new ClassAdapter());
        System.out.println("------------");
        phone.charging(new ObjectAdapter(new Voltage220V()));
    }
}
```

```
public interface interfaceDemo {
    public void fun1();
    public void fun2();
    public void fun3();
    public void fun4();
}
//InterfaceAdapter 我们将 interfaceDemo 的方法进行默认实现
public abstract class InterfaceAdapter implements interfaceDemo{
    //默认实现
    public void fun1() {

    }

    public void fun2() {

    }

    public void fun3() {

    }

    public void fun4() {

    }
}

public class Client {
    public static void main(String[] args) {
        InterfaceAdapter interfaceAdapter=new InterfaceAdapter(){
            @Override
            public void fun1() {
                System.out.println("实现fun1方法");
            }
        };
        interfaceAdapter.fun1();
    }
}
```



>  注意事项：

Java是单继承机制，所以类适配器需要继承sre类这一点算是一 -个缺点，因为这要求dst必须是接口，有一定局限性;
sre类的方法在Adapter中都会暴露出来，也增加了使用的成本。
由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

### 3.对象适配器模式

> 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承sre类，而是持有src类的实例，以解决
> 兼容性的问题。即: 持有src类， 实现dst 类接口，完成src->dst的适配
> 根据“合成复用原则”，在系统中尽量使用关联关系(聚合)来替代继承关系。
> 对象适配器模式是适配器模式常用的一种

案例：

同样是之前的例子，这里用objectadapter对象适配器，其聚合了Voltage220，直接调用Voltage220的方法实现转换

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012229481.png" alt="image-20220801222912221" style="zoom:25%;" />

>  注意事项：

对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。
根据合成复用原则，使用组合替代继承，所以它 解决了类适配器必须继承src的局限性问题，也不再要求dst
必须是接口。
使用成本更低，更灵活。

### 4.接口适配器模式

> 核心思路:当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
> 适用于一个接口不想使用其所有的方法的情况。

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012233711.png" alt="image-20220801223306965" style="zoom:25%;" />

抽象类InterfaceAdapter实现interfaceDemo接口，实现其方法，但没有添加任何具体的实现细节代码

在client调用InterfaceAdapter时，可以按照需求实现某一个方法，而不用实现其他方法

### 5.适配器模式在SpringMVC框架应用的源码剖析

![image-20220801232437321](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208012324554.png)

适配器模式的注意事项和细节
1)三种命名方式，是根据src是以怎样的形式给到Adapter (在Adapter里的形式)来
命名的。
2)类适配器:以类给到，在Adapter里，就是将src当做类，继承
对象适配器:以对象给到，在Adapter里， 将src作为 -一个对象，持有
接口适配器:以接口给到，在Adapter里，将src作为一- 个接口，实现

3)Adapter模式最 大的作用还是将原本不兼容的接口融合在一起工作。
4)实际开发中，实现起来不拘泥于我们讲解的三种经典形式

