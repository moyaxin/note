## 3.装饰者模式

### 1.介绍

> 装饰者模式:动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则(ocp)



### 2.案例：

咖啡种类/单品咖啡: Espresso( 意大利浓咖啡)、ShortBlack(单品咖啡)、 LongBlack(美式咖啡)、
调料: Milk、 Soy(豆浆)、 Chocolate
要求在扩展新的咖啡种类时，具有良好的扩展性、改动方便、维护方便
使用00的来计算不同种类咖啡的费用:客户可以点单品咖啡，也可以单品咖啡+调料组合。



Drink类是一个抽象类 ，而ShortBlack就是单品咖啡是其一个继承子类
Decorator是一个装饰类，含有一个被装饰的对象(Drink obj)
Decorator的cost方法进行一个费用的叠加计算，递归的计算价格

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022107098.png" alt="image-20220802210742954" style="zoom:33%;" />

```
public abstract class Drink {
    public String desc;
    private float price =0.0f;

    public String getDesc() {
        return desc;
    }

    public void setDesc(String desc) {
        this.desc = desc;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }
    //计算费用的抽象方法
    public abstract float cost();

}
public class Coffee extends Drink{
    public float cost() {
        return super.getPrice();
    }
}
public class Espresso extends Coffee{
    public Espresso() {
        setDesc(" 意大利咖啡 ");
        setPrice(6.0f);
    }
}
public class ShortBlack extends Coffee{
    public ShortBlack() {
        setDesc(" shortblack ");
        setPrice(4.0f);
    }
}
    public LongBlack() {
        setDesc(" longblack ");
        setPrice(5.0f);
    }
}
public class Decorator extends Drink{
    private Drink obj;

    public Decorator(Drink obj) {
        this.obj = obj;
    }

    public float cost() {
        return super.getPrice() + obj.cost();
    }

    public String getDes() {
        // obj.getDes() 输出被装饰者的信息
        return desc + " " + getPrice() + " && " + obj.getDesc();
    }
}
public class Soy extends Decorator{
    public Soy(Drink obj) {
        super(obj);
        setDesc(" 豆浆  ");
        setPrice(1.5f);
    }
}
public class Milk extends Decorator{
    public Milk(Drink obj) {
        super(obj);
        setDesc(" 牛奶 ");
        setPrice(2.0f);
    }
}
public class Chocolate extends Decorator{
    public Chocolate(Drink obj) {
        super(obj);
        setDesc(" 巧克力 ");
        setPrice(3.0f); // 调味品 的价格
    }
}
```



### 3.装饰者模式在JDK应用的源码分析

![image-20220802211930062](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022119754.png)

1. InputStream是抽象类,类似我们前面讲的Drink
2. FileInputStream是InputStream 子类，类似我们前面的DeCaf, LongBlack
3. FilterInputStream是InputStream 子类:类似我们前面的Decorator 修饰者
4. DatalnputStream是FilterInputStream 子类，具体的修饰者，类似前面的Milk, Soy等.
5. FilterInputStream类有protected volatile InputStream in;即含被装饰者
6. 分析得出在jdk的io体系中，就是使用装饰者模式
