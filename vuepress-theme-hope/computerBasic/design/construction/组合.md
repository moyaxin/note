## 4.组合模式

### 1. 基本介绍

> 组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示"整体-部分”的层次关系。
> 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式。
> 组合模式使得用户对单个对象和组合对象的访问具有一致性，即:组合能让客户以一致的方式处理个别对象以及组合对象
>
> 组合模式解决这样的问题，当我们的要处理的对象可以生成-颗树形结构，而我们要对树上的节点和叶子进行操作时，它能够提供一-致的方式，而不用考虑它是节点还是叶子

**组合模式原理图**

![image-20220802224724142](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022257402.png)
对原理结构图的说明-即(组合模式的角色及职责)

1) Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理
   Component子部件, Component可以是抽象类或者接口
2) Leaf: 在组合中表示叶子节点，叶子节点没有子节点
3) Composite :非叶子节点，用 于存储子部件，在Component接口中实现 子部件的相关操作，比如增加(add),
   删除。

### 2. 案例

编写程序展示一个学校院系结构:需求是这样，要在一个页面中展示出学校的院系组成，一个学校有多个学院， 一个学院有多个系。

organizationComponent是所有类共有的接口，用于访问和管理所有的子部件

university，college是学校和院系是非叶子结点，而department是学院是叶子结点，

university通过organizationComponent聚合了college，而college通过organizationComponent聚合了department，然后对其进行一些相关操作，比如add和删除，如果还有其他类别，直接添加对应的类别即可





![image-20220802222338235](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022223082.png)

```
public abstract class OrganizationComponent {
    private String name; // 名字
    private String des; // 说明

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getDes() {
        return des;
    }

    public void setDes(String des) {
        this.des = des;
    }

    public OrganizationComponent(String name, String des) {
        this.name = name;
        this.des = des;
    }

    protected  void add(OrganizationComponent organizationComponent) {
        //默认实现
        throw new UnsupportedOperationException();
    }

    protected  void remove(OrganizationComponent organizationComponent) {
        //默认实现
        throw new UnsupportedOperationException();
    }

    //方法print, 做成抽象的, 子类都需要实现
    protected abstract void print();
}

//University 就是 Composite , 可以管理College
public class University extends OrganizationComponent{
    //用于存College
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }


    public University(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println("*****" + getName());
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
public class College extends OrganizationComponent{
    //用于存Department
    List<OrganizationComponent> organizationComponents = new ArrayList<OrganizationComponent>();

    // 重写add
    @Override
    protected void add(OrganizationComponent organizationComponent) {
        organizationComponents.add(organizationComponent);
    }

    // 重写remove
    @Override
    protected void remove(OrganizationComponent organizationComponent) {
        organizationComponents.remove(organizationComponent);
    }

    public College(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println("--------------" + getName() + "--------------");
        //遍历 organizationComponents
        for (OrganizationComponent organizationComponent : organizationComponents) {
            organizationComponent.print();
        }
    }
}
public class Department extends OrganizationComponent{
    //没有集合

    public Department(String name, String des) {
        super(name, des);
    }

    protected void print() {
        System.out.println(getName());

    }
}
public class Client {
    public static void main(String[] args) {
        //从大到小创建对象 学校
        OrganizationComponent university = new University("清华大学", " 中国顶级大学 ");

        //创建 学院
        OrganizationComponent computerCollege = new College("计算机学院", " 计算机学院 ");
        OrganizationComponent infoEngineercollege = new College("信息工程学院", " 信息工程学院 ");


        //创建各个学院下面的系(专业)
        computerCollege.add(new Department("软件工程", " 软件工程不错 "));
        computerCollege.add(new Department("网络工程", " 网络工程不错 "));
        computerCollege.add(new Department("计算机科学与技术", " 计算机科学与技术是老牌的专业 "));


        infoEngineercollege.add(new Department("通信工程", " 通信工程不好学 "));
        infoEngineercollege.add(new Department("信息工程", " 信息工程好学 "));

        //将学院加入到 学校
        university.add(computerCollege);
        university.add(infoEngineercollege);

        //university.print();
        infoEngineercollege.print();
    }
}
```



### 3.组合模式在JDK集合的源码分析

![image-20220802223322623](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208022233036.png)

### 4.组合模式的注意事项和细节

1)简化客户端操作。客户端只需要面对--致的对象而不用考虑整体部分或者节点叶子的问题。
2)具有 较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4)需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式，
5)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式
