## 6.享元模式

### 1.基本介绍
>1)享元模式( Flyweight Pattern)也叫蝇量模式:运用共享技术有效地支持大量细粒度的对象
>2)常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
>3)享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率
>4)享元模式经典的应用场景就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

原理图：

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208032230798.png" alt="image-20220803223039144" style="zoom: 50%;" />

1. FlyWeight是抽象的享元角色，他是产品的抽象类,同时定义出对象的外部状态和内部状态的接口或实现

2) ConcreteFlyWeight 是具体的享元角色，是具体的产品类，实现抽象角色定义相关业务
3) UnSharedConcreteFlyWeight 是不可共享的角色，一般不会出现在享元工厂。
4) FlyWeightFactory 享元工厂类，用于构建一 个池容器(集合)， 同时提供从池中获取对象方法

> 内部状态和外部状态

比如围棋、五子棋、跳棋，它们都有大量的棋子对象，围棋和五子棋只有黑白两色，跳棋颜色多一点，所以棋子**颜色**就是棋子的**内部状态**;而各个棋子之间的差别就是位置的不同，当我们落子后，落子颜色是定的，但位置是变化的，所以棋子**坐标**就是棋子的**外部状态**

享元模式提出了两个要求:细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两
个部分:内部状态和外部状态
1)内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
2)外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

### 2.案例

展示网站项目需求
小型的外包项目，给客户A做一个产品展示网站，客户A的朋友感觉效果不错，也希望做这样的产品展示网
站，但是要求都有些不同:

1.有客户人要求以博客的形式发布

2.有客户要求以新闻的形式发步

3.有客户希望以微信公众号的形式发布

webSiteFactory是一个工厂，client从这个工厂中获取数据，而webSite就是抽象的享元角色，其中concreteWebsite就是内部状态也就是网站的内容，client每次从工厂中拿数据时，会判断这个website的具体内容concreteWebsite是否含有，如果有直接拿不用new对象。而这个User就是外部状态，是可以随意更改的，而这个工厂中可以只有博客、新闻、微信公众号的内容，但是可以对应很多人和网站

![image-20220803223617137](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202208032236544.png)

```
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
public abstract class WebSite {
    	public abstract void use(User user);//抽象方法
}
public class ConcreteWebSite extends WebSite {
    private String type;

    public ConcreteWebSite(String type) {
        this.type = type;
    }

    public void use(User user) {
        System.out.println("网站的发布形式为:" + type + " 在使用中 ..  使用者是" + user.getName());
    }
}
// 网站工厂类，根据需要返回一个网站
public class  WebSiteFactory {
    //集合， 充当池的作用
    private HashMap<String,ConcreteWebSite> pool=new HashMap<String, ConcreteWebSite>();
    //根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回
    public WebSite getWebSiteCategory(String type) {
        if(!pool.containsKey(type)) {
            //就创建一个网站，并放入到池中
            pool.put(type, new ConcreteWebSite(type));
        }

        return (WebSite)pool.get(type);
    }

    //获取网站分类的总数 (池中有多少个网站类型)
    public int getWebSiteCount() {
        return pool.size();
    }
}
public class Client {
    public static void main(String[] args) {
        WebSiteFactory webSiteFactory = new WebSiteFactory();
        WebSite web1=webSiteFactory.getWebSiteCategory("博客");
        web1.use(new User("张三"));
        WebSite web2=webSiteFactory.getWebSiteCategory("博客");
        web1.use(new User("李四"));
        WebSite web3=webSiteFactory.getWebSiteCategory("新闻");
        web1.use(new User("王五"));

        System.out.println("网站的分类共:"+webSiteFactory.getWebSiteCount());
    }
}
```

### 3.享元模式在JDK-Interger的应用源码分析

```
Integer x = Integer.valueOf(127); // 得到 x实例，类型 Integer
        Integer y = new Integer(127); // 得到 y 实例，类型 Integer
        Integer z = Integer.valueOf(127);//..
        Integer w = new Integer(127);
        System.out.println(x.equals(y)); // 大小，true
        System.out.println(x == y ); //  false
        System.out.println(x == z ); // true
        System.out.println(w == x ); // false
        System.out.println(w == y ); // false
        Integer x1 = Integer.valueOf(200);
        Integer x2 = Integer.valueOf(200);
        System.out.println(x1 == x2); // false
```

valueOf 方法，就使用到享元模式

如果 Integer.valueOf(x) x 在  [-128, 127]直接，就是使用享元模式返回,如果不在范围类，则仍然 new

在valueOf 方法中，先判断值是否在 IntegerCache 中，如果不在，就创建新的Integer(new), 否则，就直接从 缓存池返回

**在此范围内的“小”整数使用率比大整数要高，使用相同的底层对象，可以减少潜在的内存占用**

> 想起之前看到的关于Java的笑话，使用integer要小心，因为100=100，而200！=200，当然也可以让100！=100，200=200
