---
sticky: true
date: 2022-08-01
category:
- 设计模式
tag:
- 知识点 

---
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活
<!-- more -->

# 创建型模式
::: info
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活
:::
## 单例模式

### 1.饿汉式（静态常量）:star:

- 优点：这种写法比较简单，就是在类装载的时候就完成实例化，避免了线程同步的问题
- 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果，如果从始至终从未使用过这个实例，则会造成内存浪费

**这种单例模式可用，但可能造成内存浪费**

### 2.饿汉式（静态代码块）

同上一个

### 3.懒汉式 线程不安全



- 起到了Lazy Loading的效果，但是只能在单线程下使用
- 多线程情况下，一个线程进入了if判断，还未往下执行，另一个线程也通过了if判断就会产生多个实例

**不要使用这种方式**

### 4.懒汉式 线程安全 同步代码块 双重检查:star:

![img](https://cdn.nlark.com/yuque/0/2022/png/26424970/1658842966061-2270e753-d76e-4ff4-a575-32b40d79d144.png)

- Double-Check概念是多线程开发中常使用到的，因为用了两次if判断检查，可以保证线程安全
- 此外，实例代码只执行一次，下次执行的时候，会因为外面的if判断而直接return实例化对象，避免反复进行方法同步

**线程安全、延迟加载、效率较高，推荐使用**



### 5.静态内部类 :star:

- 使用了类装载的机制来保证初始化实例时只有一个线程
- 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实力化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化
- 类的静态属性只会在第一次加载类的时候初始化，JVM帮助我保证了线程的安全性，在类进行初始化，别的线程是无法进入的

**避免了线程不安全，利用静态内部类特点实现延迟加载，效率高，推荐使用**



### 6.枚举  :star



借助JDK1.5中添加的枚举来实现单例模式，不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象



### 7.单例模式的注意事项和细节说明



1. 单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以保证系统性能
2. 当想要实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3. **使用场景：**需要**频繁的进行创建和销毁的对象**、创建对象时耗时过多或耗费资源过多（重量级对象），但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象（如数据源、session工厂）

### 8.单例模式在JDK应用的源码分析

```
Runtime runtime=Runtime.getRuntime();
```

![image-20220731135307050](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050656.png)

## 工厂模式

1.工厂模式的意义
将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项
目的扩展和维护性。
2.三种工厂 模式(简单工厂模式、工厂方法模式、抽象工厂模式)
3.设计模式的依赖抽象原则

- 创建对 象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。有的书上说，
  变量不要直接持有具体类的引用。
- 不要让类继承具体类，而是继承抽象类或者是实现interface(接口)
- 不要覆盖基类中已经实现的方法。

### 1.简单工厂

简单工厂模式是属于创建型模式，它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。

简单工厂模式:定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050466.png" alt="image-20220731122248568" style="zoom:25%;" />

### 2.工厂方法



1)工厂方法模式设计方案:将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
2)工厂方法模式:定义了-一个创建对象的抽象方法，由子类决定要实例化的类，把实例化操作推迟到子类

披萨项目新的需求:客户在点披萨时,可以点不同口味的披萨，比如北京的奶酪pizza、 北京的胡椒pizza或是伦敦的奶酪pizza、 伦敦的胡椒pizza

<img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050532.png" alt="image-20220731123520803" style="zoom:25%;" />

### 3.抽象工厂 

定义:抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口， 无需指定它们具体的类

> - 抽象工厂模式:定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
> - 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
> - 从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一 步的抽象)。
> - 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

适用场景:

客户端(应用层)不依赖于产品类实例如何被创建、实现等细节
强调一-系列相关的产品对象(属于同-产品族)-起使用创建对象需要大量的重复代码
提供一个产品类的库,所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现

优点:

具体产品在应用层的代码隔离，无需关心创建的细节
将一个系列的产品统一到一起创建

缺点:

规定了所有可能被创建的产品集合,产品簇中扩展新的产品困难;
增加了系统的抽象性和理解难度



案例：

![image-20220731115432207](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050125.png)

有两个产品：蛋糕cake和披萨pizza（接口）
然后有两个店：上海和北京店负责具体的生产

现在有一个抽象工厂可以生产cake和pizza

然后北京和上海两个工厂继承这个抽象工厂，其主要是用店来具体生产

而客户端只要调用这两个子工厂即可实现生产工厂

### 4. 工厂模式在JDK-Calendar 应用的源码分析

```
Calendar calendar=Calendar.getInstance();
```

![image-20220731135102063](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050415.png)



## 原型模式

### 1.介绍

> 原型模式(Prototype模式) ，用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
> 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
> 工作原理是:通过将-一个原型对象传给那个要发动创建的对象,这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()



案例：

现在有一只羊tom,姓名为:tom,年龄为: 1，颜色为:白色， 请编写程序创建和tom羊属性完全相同的10 .
只羊。

最容易想到的就是直接用构造方法，造十个

还有就是直接实现cloneable接口，用clone方法

```

public class CloneSheep {
    public static void main(String[] args) {
        //原始的拷贝
        Sheep sheep = new Sheep("duoli",13,"blue");
        Sheep sheep1 = new Sheep("duoli", 13, "blue");
        Sheep sheep2 = new Sheep("duoli", 13, "blue");
        Sheep sheep3 = new Sheep("duoli", 13, "blue");
        Sheep sheep4 = new Sheep("duoli", 13, "blue");
        //如果sheep发生了改变，比如多了一个属性，那么1234都要加个属性



        //使sheep实现cloneable接口，使用其默认的clone方法
        //可以解决sheep发生改变，而以下代码无需改变
        Sheep sheep_ = new Sheep("duoli",14,"blue");
        Sheep clone1 = sheep_.clone();
        Sheep clone2 = sheep_.clone();
        Sheep clone3 = sheep_.clone();
        Sheep clone4 = sheep_.clone();

    }
}
```



### 2.**浅拷贝的介绍**

> 1). 对于数据类型是基本数据类型的成员变量,浅拷贝会直接进行值传递，也就是将该属性值复制--份给新的对象。
> 2). 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值(内存地址)复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值

前面我们克隆羊就是浅拷贝
浅拷贝是使用默认的clone()方法来实现

### 3.**深拷贝的介绍**

> 复制对象的所有基本数据类型的成员变量值
> 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象
> 可达的所有对象。也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型)进行拷贝
> 深拷贝实现方式1:重写clone方法来实现深拷贝
> 深拷贝实现方式2:通过对象序列化实现深拷贝(推荐)

案例：上诉的sheep加一个引用类型：sheepType

然后两种深拷贝的实现方式如下：

```
//深拷贝 - 方式 1 使用clone 方法
	@Override
	protected Sheep clone()  {

		Sheep sheep = null;
		try {
			sheep = (Sheep)super.clone();
			//对引用属性单独处理
			sheep.sheepType=(SheepType)sheepType.clone();
		} catch (Exception e) {
			// TODO: handle exception
			System.out.println(e.getMessage());
		}
		return sheep;
	}
	
	
	//深拷贝 - 方式2 通过对象的序列化实现 (推荐)
	public Sheep deepClone(){
		//创建流对象
		ByteArrayOutputStream bos=null;
		ObjectOutputStream oos=null;

		ByteArrayInputStream bis=null;
		ObjectInputStream ois=null;

		Sheep sheep =null;
		try{
			//先序列化
			bos=new ByteArrayOutputStream();
			oos=new ObjectOutputStream(bos);
			oos.writeObject(this); //当前这个对象以对象流的方式输出

			//再反序列化
			bis=new ByteArrayInputStream(bos.toByteArray());
			ois=new ObjectInputStream(bis);
			sheep=(Sheep) ois.readObject();
		}catch (Exception e){
			e.printStackTrace();
		}finally {
			//关闭流
			try {
				bos.close();
				oos.close();
				bis.close();
				ois.close();
			} catch (Exception e2) {
				// TODO: handle exception
				System.out.println(e2.getMessage());
			}
		}
		return sheep;
	}
```

### 4.原型模式在Spring框架中源码分析
![image-20220731155552062](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050709.png)





## 建造者模式

### 1.介绍

> 建造者模式(BuilderPattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出
> 来(抽象类别)，使这个抽象过程的不同实现方法可以构造出不同表现(属性)的对象。
> 建造者模式是一步一步创建一一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

建造者模式的四个角色

- Product (产品角色) : 一个具体的产品对象。
- Builder (抽象建造者) :创建-一个Product对象的各个部件指定的接口/抽象类。
- ConcreteBuilder (具体建造者) :实现接口，构建和装配各个部件。
- Director (指挥者) :构建一个使用Builder 接口的对象。它主要是用于创建一一个 复杂的对象。它主要有两个作用，一是:隔离了客户与对象的生产过程，二是:负责控制产品对象的生产过程。

### 2.案例

需要建房子:这一过程为打桩、砌墙、封顶。不管是普通房子也好，别墅也好都需要经历这些过程

house是我们需要建的房子，然后有一个houseBuilder聚合了house（对象），里面有一些抽象的建房子的过程

然后commonHouse普通房子和businessHouse商品房继承houseBuilder，具体实现建房子过程的那些方法

然后有一个指挥者houseDiretor组合了houseBuilder（属性），调用houseBuilder的那些建房子的过程

客户端client只需要new 一个commonHouse或者businessHouse对象并交给houseDiretor指挥者，并可以建造对应的房子

![image-20220731203643799](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312050067.png)

### 3.建造者模式在JDK的应用和源码分析

![image-20220731204601001](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/2025/202207312049675.png)

Appendable 接口定义了多个append方法(抽象方法), 即Appendable 为抽象建

造者, 定义了抽象方法 AbstractStringBuilder 实现了 Appendable 接口方法，这里的

AbstractStringBuilder 已经是建造者，只是不能实例化

StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的

实现是由 AbstractStringBuilder 完成, 而StringBuilder 继承了AbstractStringBuilder 

### **4.建造者模式的注意事项和细节**

**1)** 客户端(使用程序)**不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象**

**2)** 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， **用户使用不同的具体建造者即可得到不同的产品对象**

**3)** **可以更加精细地控制产品的创建过程** 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程

**4)** **增加新的具体建造者无须修改原有类库的代码**，指挥者类针对抽象建造者类编程，系统扩展方便，符合 **“开闭原则"**

**5)** 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

**6)** 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.

**7)** **抽象工厂模式**VS**建造者模式**

抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品